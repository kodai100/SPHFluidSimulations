#pragma kernel buildGrid
#pragma kernel buildGridIndices
#pragma kernel rearrangeParticles
#pragma kernel sph

struct Particle {
	float3 position;
	float3 velocity;
	float3 force;
	float density;
	float pressure;
};

struct HashGridKeyValue {
	unsigned int key;
	unsigned int value;
};

struct GridIndices {
	unsigned int start;
	unsigned int end;
};

#define SIMULATION_BLOCK_SIZE 256
#define PI 3.141592653589793
#define EPSILON 1e-4f

StructuredBuffer<Particle> _ParticleBufferRead;
RWStructuredBuffer<Particle> _ParticleBufferWrite;

StructuredBuffer  <HashGridKeyValue> _GridBufferRead;
RWStructuredBuffer<HashGridKeyValue> _GridBufferWrite;

StructuredBuffer  <GridIndices> _GridIndicesBufferRead;
RWStructuredBuffer<GridIndices> _GridIndicesBufferWrite;

cbuffer CB {
	int _NumParticles;
	float _RestDensity;
	float _PressureStiff;
	float _PMass;
	float _SimScale;
	float _SmoothStep;
	float _DT;
	float _Viscosity;
	float _VelLimit;
	float _Radius;
	float _WallStiff;
	float _Restitution;
	float3 _Min;
	float3 _Max;
	float3 _Gravity;
	float _DensityCoef;
	float _GradPressureCoef;
	float _LapViscosityCoef;
	float3 _GridDim;
};

float3 GridCalculateCell(float3 position) {
	return clamp(position * _GridDim.xyz / _Max, float3(0, 0, 0), float3(255, 255, 255));
}

uint GridConstructKey(uint3 xyz) {
	// Bit pack [-----UNUSED-----][----Y---][----X---][----Z---]
	//                16-bit         8-bit     8-bit     8-bit
	return dot(xyz.zyx, uint3(256 * 256, 256, 1));
}

HashGridKeyValue GridConstructKeyValuePair(uint3 xyz, uint value) {
	HashGridKeyValue h;
	h.key = GridConstructKey(xyz);
	h.value = value;
	return h;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void buildGrid(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int id = DTid.x;

	float3 position = _ParticleBufferRead[id].position;
	float3 grid_xyz = GridCalculateCell(position);

	_GridBufferWrite[id] = GridConstructKeyValuePair((uint3)grid_xyz, id);
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void buildGridIndices(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int id = DTid.x;
	unsigned int id_prev = (id == 0) ? (uint)_NumParticles : id - 1;
	unsigned int id_next = (id == (uint)_NumParticles) ? 0 : id + 1;

	// セル毎にパーティクルidのスタートとエンドを決定
	// GridBufferReadはソート済み
	unsigned int cell = _GridBufferRead[id].key;				// 現在いるセルのインデックスを取得
	unsigned int cell_prev = _GridBufferRead[id_prev].key;		// 1つ手前のidを持ったパーティクルのセルインデックスを取得
	unsigned int cell_next = _GridBufferRead[id_next].key;		// 1つ後のidを持ったパーティクルのセルインデックスを取得

	// 自分のいるセルと1個手前パーティクルがいるセルが異なる場合
	if (cell != cell_prev) {
		// I'm the start of a cell
		_GridIndicesBufferWrite[cell].start = id;
	}
	if (cell != cell_next) {
		// I'm the end of a cell
		_GridIndicesBufferWrite[cell].end = id + 1;
	}
}


[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void rearrangeParticles(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int ID = DTid.x;
	const unsigned int G_ID = _GridBufferRead[ID].key;	// パーティクルのあるセルid

	_ParticleBufferWrite[ID] = _ParticleBufferRead[G_ID];
}



[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void sph(uint3 DTid : SV_DispatchThreadID) {

	const unsigned int id = DTid.x;
	Particle particle = _ParticleBufferRead[id];

	// calc amount ---------------------------------------------
	float r2, c;
	float3 dr;
	float h2 = _SmoothStep * _SmoothStep; // 有効半径の2乗

	float sum = 0.0;

	int X, Y, Z;
	// グリッド走査
	int3 G_XYZ = (int3)GridCalculateCell(particle.position);
	for (Z = max(G_XYZ.z - 1, 0); Z <= min(G_XYZ.z + 1, 255); Z++) {
		for (Y = max(G_XYZ.y - 1, 0); Y <= min(G_XYZ.y + 1, 255); Y++) {
			for (X = max(G_XYZ.x - 1, 0); X <= min(G_XYZ.x + 1, 255); X++) {
				unsigned int G_CELL = GridConstructKey(uint3(X, Y, Z));
				GridIndices G_START_END = _GridIndicesBufferRead[G_CELL];
				for (unsigned int N_ID = G_START_END.start; N_ID < G_START_END.end; N_ID++) {
					float3 N_position = _ParticleBufferRead[N_ID].position;

					dr = (N_position - particle.position) * _SimScale;
					r2 = dot(dr, dr);
					if (r2 < h2) {
						c = h2 - r2;
						sum += c*c*c;
					}
				}
			}
		}
	}

	particle.density = (float)sum * _PMass * _DensityCoef;
	particle.pressure = _PressureStiff * max(pow(particle.density / _RestDensity, 3) - 1, 0);
	particle.density = 1.0 / (particle.density + 1e-4);
	// calc amount -------------------------------------------


	// calc force --------------------------------------------
	float3 pterm, vterm;
	float r;
	float3 force, fcurr;

	force = float3(0, 0, 0);

	// グリッド走査
	for (Z = max(G_XYZ.z - 1, 0); Z <= min(G_XYZ.z + 1, 255); Z++) {
		for (Y = max(G_XYZ.y - 1, 0); Y <= min(G_XYZ.y + 1, 255); Y++) {
			for (X = max(G_XYZ.x - 1, 0); X <= min(G_XYZ.x + 1, 255); X++) {
				unsigned int G_CELL = GridConstructKey(uint3(X, Y, Z));
				GridIndices G_START_END = _GridIndicesBufferRead[G_CELL];
				for (unsigned int N_ID = G_START_END.start; N_ID < G_START_END.end; N_ID++) {
					float3 N_position = _ParticleBufferRead[N_ID].position;

					dr = (N_position - particle.position) * _SimScale;
					r = sqrt(dot(dr, dr));
					if (r < _SmoothStep) {
						c = _SmoothStep - r;
						pterm = -0.5 * c * c * _GradPressureCoef / r * (particle.pressure + _ParticleBufferRead[N_ID].pressure) * dr;
						vterm = _LapViscosityCoef * _Viscosity * c * (_ParticleBufferRead[N_ID].velocity - particle.velocity);
						fcurr = pterm + vterm;
						fcurr *= _PMass * _ParticleBufferRead[N_ID].density;
						force += fcurr;
					}
				}
			}
		}
	}

	particle.force = force;
	// calc force --------------------------------------------


	// calc advance --------------------------------------------
	float3 accel, g, norm;
	float speed, diff, adj;

	g = _Gravity;

	// Penalty method
	accel = particle.force * particle.density;

	speed = dot(accel, accel);
	if (speed > _VelLimit * _VelLimit) {
		accel *= _VelLimit / sqrt(speed);
	}

	// Z-axis walls
	diff = 2.0 * _Radius - (particle.position.z - _Min.z) * _SimScale;
	if (diff > EPSILON) {
		norm = float3(0, 0, 1);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}
	diff = 2 * _Radius - (_Max.z - particle.position.z) * _SimScale;
	if (diff > EPSILON) {
		norm = float3(0, 0, -1);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}

	// X-axis walls
	diff = 2.0 * _Radius - (particle.position.x - _Min.x) * _SimScale;
	if (diff > EPSILON) {
		norm = float3(1, 0, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}
	diff = 2.0 * _Radius - (_Max.x - particle.position.x) * _SimScale;
	if (diff > EPSILON) {
		norm = float3(-1, 0, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}

	// Y-axis walls
	diff = 2.0 * _Radius - (particle.position.y - _Min.y) * _SimScale;
	if (diff > EPSILON) {
		norm = float3(0, 1, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}
	diff = 2.0 * _Radius - (_Max.y - particle.position.y) * _SimScale;
	if (diff > EPSILON) {
		norm = float3(0, -1, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}

	accel += g;
	
	particle.velocity += accel * _DT;
	particle.position += particle.velocity * _DT / _SimScale;
	// calc force --------------------------------------------

	_ParticleBufferWrite[id] = particle;
	
}