#pragma kernel buildGrid
#pragma kernel sph

struct Particle {
	float3 position;
	float3 velocity;
	float3 force;
	float density;
	float pressure;
};

struct HashGridKeyValue {
	unsigned int key;
	unsigned int value;
};

#define SIMULATION_BLOCK_SIZE 32
#define PI 3.141592653589793

StructuredBuffer<Particle> _ParticleBufferRead;
RWStructuredBuffer<Particle> _ParticleBufferWrite;

StructuredBuffer  <HashGridKeyValue>           _GridBufferRead;
RWStructuredBuffer<HashGridKeyValue>           _GridBufferWrite;

StructuredBuffer  <uint2>           _GridIndicesBufferRead;
RWStructuredBuffer<uint2>           _GridIndicesBufferWrite;

cbuffer CD {
	int _NumParticles;
	float _RestDensity;
	float _PressureStiff;
	float _PMass;
	float _SimScale;
	float _SmoothStep;
	float _DT;
	float _Viscosity;
	float _VelLimit;
	float _Radius;
	float _WallStiff;
	float _Restitution;
	float3 _Min;
	float3 _Max;
	float3 _Gravity;
	float _DensityCoef;
	float _GradPressureCoef;
	float _LapViscosityCoef;
	float3 _GridDim;
};

float3 GridCalculateCell(float3 position) {
	return position * _GridDim.xyz / _Max;
}

uint GridConstructKey(uint3 xyz) {
	// Bit pack [-----UNUSED-----][----Y---][----X---][----Z---]
	//                16-bit         8-bit     8-bit     8-bit
	return dot(xyz.zyx, uint3(256 * 256, 256, 1));
}

HashGridKeyValue GridConstructKeyValuePair(uint3 xyz, uint value) {
	HashGridKeyValue h;
	h.key = GridConstructKey(xyz);
	h.value = value;
	return h;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void buildGrid(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int id = DTid.x;

	float3 position = _ParticleBufferRead[id].position;
	float3 grid_xyz = GridCalculateCell(position);

	_GridBufferWrite[id] = GridConstructKeyValuePair((uint3)grid_xyz, id);
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void sph(uint3 DTid : SV_DispatchThreadID) {

	const unsigned int id = DTid.x;
	Particle particle = _ParticleBufferRead[id];

	// calc amount ---------------------------------------------
	float r2, c;
	float3 dr;
	float H2 = _SmoothStep * _SmoothStep; // 有効半径の2乗

	float sum = 0.0;

	for (unsigned int j = 0; j < (uint)_NumParticles; j++) {
		if (id == j) continue;
		else {
			dr = (particle.position - _ParticleBufferRead[j].position) * _SimScale;
			r2 = dot(dr, dr);
			if (H2 > r2) {
				c = H2 - r2;
				sum += c * c * c;
			}
		}
	}

	particle.density = (float)sum * _PMass * _DensityCoef;
	particle.pressure = _PressureStiff * max(pow(particle.density / _RestDensity, 3) - 1, 0);
	particle.density = 1.0 / (particle.density + 1e-4);
	// calc amount -------------------------------------------


	// calc force --------------------------------------------
	float3 pterm, vterm;
	float r;
	float3 force, fcurr;

	force = float3(0, 0, 0);

	for (unsigned int j = 0; j < (uint)_NumParticles; j++) {
		if (id == j) continue;
		else {
			dr = (particle.position - _ParticleBufferRead[j].position) * _SimScale;
			r = sqrt(dot(dr, dr));
			if (_SmoothStep > r) {
				c = _SmoothStep - r;
				pterm = -0.5 * c * c * _GradPressureCoef / r * (particle.pressure + _ParticleBufferRead[j].pressure) * dr;
				vterm = _LapViscosityCoef * _Viscosity * c * (_ParticleBufferRead[j].velocity - particle.velocity);
				fcurr = pterm + vterm;
				fcurr *= _PMass * _ParticleBufferRead[j].density;
				force += fcurr;
			}
		}
	}

	particle.force = force;
	// calc force --------------------------------------------


	// calc advance --------------------------------------------
	float3 accel, g, norm;
	float speed, diff, adj;

	g = _Gravity;

	// Penalty method
	accel = particle.force * particle.density;

	speed = dot(accel, accel);
	if (speed > _VelLimit * _VelLimit) {
		accel *= _VelLimit / sqrt(speed);
	}

	// Z-axis walls
	diff = 2.0 * _Radius - (particle.position.z - _Min.z) * _SimScale;
	if (diff > 0) {
		norm = float3(0, 0, 1);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}
	diff = 2 * _Radius - (_Max.z - particle.position.z) * _SimScale;
	if (diff > 0) {
		norm = float3(0, 0, -1);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}

	// X-axis walls
	diff = 2.0 * _Radius - (particle.position.x - _Min.x) * _SimScale;
	if (diff > 0) {
		norm = float3(1, 0, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}
	diff = 2.0 * _Radius - (_Max.x - particle.position.x) * _SimScale;
	if (diff > 0) {
		norm = float3(-1, 0, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}

	// Y-axis walls
	diff = 2.0 * _Radius - (particle.position.y - _Min.y) * _SimScale;
	if (diff > 0) {
		norm = float3(0, 1, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}
	diff = 2.0 * _Radius - (_Max.y - particle.position.y) * _SimScale;
	if (diff > 0) {
		norm = float3(0, -1, 0);
		adj = _WallStiff * diff - _Restitution * dot(norm, particle.velocity);
		accel += adj * norm;
	}

	accel += g;
	
	particle.velocity += accel * _DT;
	particle.position += particle.velocity * _DT / _SimScale;
	// calc force --------------------------------------------

	_ParticleBufferWrite[id] = particle;
	
}